[{"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/index.js":"1","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/App.js":"2","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/reportWebVitals.js":"3","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Visuals.jsx":"4","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dfs.js":"5","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dijkstra.js":"6","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/bfs.js":"7","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/aStar_tester.js":"8","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Node/Node.jsx":"9"},{"size":500,"mtime":1611605828300,"results":"10","hashOfConfig":"11"},{"size":227,"mtime":1612021092465,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":1611605828301,"results":"13","hashOfConfig":"11"},{"size":22140,"mtime":1615128344690,"results":"14","hashOfConfig":"11"},{"size":2633,"mtime":1612321180424,"results":"15","hashOfConfig":"11"},{"size":2714,"mtime":1612296205030,"results":"16","hashOfConfig":"11"},{"size":4125,"mtime":1612323414317,"results":"17","hashOfConfig":"11"},{"size":4304,"mtime":1612558553563,"results":"18","hashOfConfig":"11"},{"size":981,"mtime":1612278640960,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1e1niwb",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/index.js",[],["40","41"],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/App.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/reportWebVitals.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Visuals.jsx",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dfs.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dijkstra.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/bfs.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/aStar_tester.js",["42"],"// Performs a* algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n// This is a modified Disjkstra's, with very similar code,\n// and is not optimal in terms of time complexity given that we're not implementing\n// a priority queue as a 'frontier,' but rather a list, and we're sorting this list\n// every loop... terribly inefficient.\n// For a more efficient version, check out my github numbers puzzle code:\n// https://github.com/annarekow/Artificial-Intelligence/blob/master/puzzle.py\n\nexport function aStar(grid, startNode, finishNode) {\n    //console.log('in AStar');\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    //finishNode.distance = Infinity;\n    //console.log(startNode, finishNode);\n    calculateTotalCost(startNode, finishNode);\n    const unvisitedNodes = getAllNodes(grid);\n    //console.log(unvisitedNodes);\n    while (!!unvisitedNodes.length) {\n        sortNodesByTotalCost(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        // if there's a wall, we skip it\n        if (closestNode.isWall) continue;\n        // if closest node has distance of infinity - ie there's no path to finish node,\n        // we are trapped, and must stop\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) {\n            // console.log('done!');\n            //console.log(visitedNodesInOrder);\n            return visitedNodesInOrder;\n        }\n        updateUnvisitedNeighbors(closestNode, grid, finishNode);\n    }\n}\n\n\nfunction sortNodesByTotalCost(unvisitedNodes) {\n    // rather than distance from start, like dijkstra's, we're sorting by total cost now\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalCost - nodeB.totalCost);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n        calculateTotalCost(neighbor, finishNode);\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            //const newNode = resetNode(node);\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction resetNode(node) {\n    const newNode = {\n        ...node,\n        distance: node.isStart ? 0 : Infinity,\n        isVisited: false,\n        transitioning: false,\n    };\n    return newNode\n}\n\n// Backtracks from the finish node to find the shortest path\n// Only works when called *after* the dijkstra method above\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\n///*************///\n\nfunction calculateTotalCost(node, finishNode) {\n    // calculates the manhattan distance of a node to the finish node - this is an estimate and doesn't account for the presence of walls\n    //console.log('calculateTotalCost');\n    //console.log(node, finishNode);\n    if (!(node.isWall)) {\n        node.distToEnd = Math.abs(finishNode.row - node.row) + Math.abs(finishNode.col - node.col);\n    }\n    calculateHeuristics(node);\n}\nfunction calculateHeuristics(node) {\n    // adds Manhattan distance to node's distance\n    // only call after given node's distance from start and manhattan distance have been updated\n    const dist = node.distance + node.distToEnd;\n    node.totalCost =  dist;\n}","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Node/Node.jsx",[],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":76,"column":10,"nodeType":"49","messageId":"50","endLine":76,"endColumn":19},"no-native-reassign",["51"],"no-negated-in-lhs",["52"],"no-unused-vars","'resetNode' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]