[{"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/index.js":"1","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/App.js":"2","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/reportWebVitals.js":"3","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Visuals.jsx":"4","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dfs.js":"5","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dijkstra.js":"6","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/bfs.js":"7","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/aStar_tester.js":"8","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Node/Node.jsx":"9"},{"size":500,"mtime":1611605828300,"results":"10","hashOfConfig":"11"},{"size":227,"mtime":1612021092465,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":1611605828301,"results":"13","hashOfConfig":"11"},{"size":20222,"mtime":1617487392451,"results":"14","hashOfConfig":"11"},{"size":2420,"mtime":1617487766302,"results":"15","hashOfConfig":"11"},{"size":2896,"mtime":1617484692804,"results":"16","hashOfConfig":"11"},{"size":2279,"mtime":1617487615180,"results":"17","hashOfConfig":"11"},{"size":3826,"mtime":1617386597733,"results":"18","hashOfConfig":"11"},{"size":1005,"mtime":1617481485657,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1e1niwb",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/index.js",[],["40","41"],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/App.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/reportWebVitals.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Visuals.jsx",["42","43","44","45","46","47","48"],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dfs.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/dijkstra.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/bfs.js",[],"/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/PathfindingAlgorithms/aStar_tester.js",["49"],"// Performs a* algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n// This is a modified Disjkstra's, with very similar code,\n// and is not optimal in terms of time complexity given that we're not implementing\n// a priority queue as a 'frontier,' but rather a list, and we're sorting this list\n// every loop... terribly inefficient.\n// For a more efficient version, check out my github numbers puzzle code:\n// https://github.com/annarekow/Artificial-Intelligence/blob/master/puzzle.py\n\nexport function aStar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    calculateTotalCost(startNode, finishNode);\n    const unvisitedNodes = getAllNodes(grid);\n    while (!!unvisitedNodes.length) {\n        sortNodesByTotalCost(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n        // if closest node has distance of infinity - ie there's no path to finish node,\n        // we are trapped, and must stop\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) {\n            return visitedNodesInOrder;\n        }\n        updateUnvisitedNeighbors(closestNode, grid, finishNode);\n    }\n}\n\n\nfunction sortNodesByTotalCost(unvisitedNodes) {\n    // rather than distance from start, like dijkstra's, we're sorting by total cost now\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalCost - nodeB.totalCost);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n        calculateTotalCost(neighbor, finishNode);\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction resetNode(node) {\n    const newNode = {\n        ...node,\n        distance: node.isStart ? 0 : Infinity,\n        isVisited: false,\n        transitioning: false,\n    };\n    return newNode\n}\n\n// Backtracks from the finish node to find the shortest path\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nfunction calculateTotalCost(node, finishNode) {\n    // calculates the manhattan distance of a node to the finish node - this is an estimate and doesn't account for the presence of walls\n    if (!(node.isWall)) {\n        node.distToEnd = Math.abs(finishNode.row - node.row) + Math.abs(finishNode.col - node.col);\n    }\n    calculateHeuristics(node);\n}\nfunction calculateHeuristics(node) {\n    // adds Manhattan distance to node's distance\n    // only call after given node's distance from start and manhattan distance have been updated\n    const dist = node.distance + node.distToEnd;\n    node.totalCost =  dist;\n}","/Users/annarekow/Desktop/2021_Projects/Visualize_Alg/src/Visuals/Node/Node.jsx",[],{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","severity":1,"message":"55","line":156,"column":17,"nodeType":"56","endLine":156,"endColumn":52},{"ruleId":"54","severity":1,"message":"55","line":180,"column":21,"nodeType":"56","endLine":180,"endColumn":56},{"ruleId":"54","severity":1,"message":"55","line":192,"column":17,"nodeType":"56","endLine":192,"endColumn":52},{"ruleId":"57","severity":1,"message":"58","line":196,"column":13,"nodeType":"59","messageId":"60","endLine":196,"endColumn":23},{"ruleId":"54","severity":1,"message":"55","line":207,"column":21,"nodeType":"56","endLine":207,"endColumn":56},{"ruleId":"61","severity":1,"message":"62","line":485,"column":29,"nodeType":"63","messageId":"64","endLine":485,"endColumn":31},{"ruleId":"61","severity":1,"message":"62","line":485,"column":65,"nodeType":"63","messageId":"64","endLine":485,"endColumn":67},{"ruleId":"57","severity":1,"message":"65","line":68,"column":10,"nodeType":"59","messageId":"60","endLine":68,"endColumn":19},"no-native-reassign",["66"],"no-negated-in-lhs",["67"],"react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","no-unused-vars","'PREV_CLASS' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'resetNode' is defined but never used.","no-global-assign","no-unsafe-negation"]